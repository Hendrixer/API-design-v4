{"pageProps":{"post":{"attributes":{"description":"Creating DB models with with Primsa"},"html":"<h2 id=\"prisma-syntax\">Prisma Syntax</h2>\n<p>Prisma has an easy to understand syntax for creating models. Its based on the GraphQL language which is based on JSON. So you&#39;ll feel right at home. I highly recommend installing the Prisma VS Code plugin. It lints and cleans up your schema file.</p>\n<br>\nNow, onto the models. Let's look at an example model.\n<br>\n\n<pre><code class=\"hljs language-prisma\">model Post {\n  // id field that is a number and automatically increments after its used\n  id        Int      @id @default(autoincrement())\n  // timestamps\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  // limit to 255 for indexing UTF-8\n  title     String   @db.VarChar(255)\n  // optional\n  content   String?\n  published Boolean  @default(false)\n  // relation to another model\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n}\n</code></pre>\n<p>Most of this is self explanatory, but check out the comments in the code to learn a bit more context. This isn&#39;t a prisma course, so we&#39;re going to keep moving along on our API. The rest of the modeling looks very much like this.</p>\n<h2 id=\"user\">User</h2>\n<pre><code class=\"hljs language-prisma\">model User {\n  id        String    @id @default(uuid())\n  createdAt DateTime  @default(now())\n  username  String    @unique\n  password  String\n  updates     Update[]\n}\n</code></pre>\n<p>Above is our User schema</p>\n<h2 id=\"product\">Product</h2>\n<pre><code class=\"hljs language-prisma\">model Product {\n  id          String   @id @default(uuid())\n  createdAt   DateTime @default(now())\n  name        String\n  belongsTo   User     @relation(fields: [belongsToId], references: [id])\n  belongsToId String\n  updates     Update[]\n}\n</code></pre>\n<p>Here we have a Product schema. For the change log app, the user might have many products they want to update. So we need a place to store multiple updates. So <code>products</code> belong to a <code>User</code>.</p>\n<h2 id=\"update\">Update</h2>\n<pre><code class=\"hljs language-prisma\">enum UPDATE_STATUS {\n  IN_PROGRESS\n  LIVE\n  DEPRECATED\n  ARCHIVED\n}\n\nmodel Update {\n  id        String   @id @default(uuid())\n  createdAt DateTime @default(now())\n  updatedAt DateTime\n\n  title   String        @db.VarChar(255)\n  body    String\n  status  UPDATE_STATUS @default(IN_PROGRESS)\n  version String?\n  asset   String\n\n  productId    String\n  product      Product       @relation(fields: [productId], references: [id])\n  updatePoints UpdatePoint[]\n}\n</code></pre>\n<p>Products can have updates. So products belong to updates. Updates have many fields, one is called status. Because status is a finite set of options, we created an ENUM to represent our status. Think of an enum value types as &quot;one-of-these&quot;. So the value must be one of the values in the ENUM instead of being any other random string.</p>\n<h2 id=\"update-points\">Update Points</h2>\n<pre><code class=\"hljs language-prisma\">model UpdatePoint {\n  id        String   @id @default(uuid())\n  createdAt DateTime @default(now())\n  updatedAt DateTime\n\n  name        String @db.VarChar(255)\n  description String\n\n  updateId String\n  update   Update @relation(fields: [updateId], references: [id])\n}\n</code></pre>\n<p>And finally, update points are the bullets points on an update. They belong to an update, which belongs to a product, which belongs to a user.</p>\n<br>\nAs we continue to build, we will most likely make changes to our schema to fit the experience we want to create.\n","slug":"creating-models","title":"Creating Models","section":"Data Modeling","icon":"shapes","filePath":"/home/runner/work/API-design-v4/API-design-v4/lessons/05-data-modeling/B-creating-models.md","nextSlug":"/API-design-v4/lessons/data-modeling/first-migrations","prevSlug":"/API-design-v4/lessons/data-modeling/design-a-schema"}},"__N_SSG":true}